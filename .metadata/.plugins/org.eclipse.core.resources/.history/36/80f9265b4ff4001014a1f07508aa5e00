/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file    app_netxduo.c
  * @author  MCD Application Team
  * @brief   NetXDuo applicative file
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2020-2021 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */

/* USER CODE END Header */

/* USER CODE BEGIN 1 */

/* USER CODE END 1 */

/* Includes ------------------------------------------------------------------*/
#include "app_netxduo.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include   "main.h"
#include   "nx_web_http_server.h"
#include   "app_filex.h"
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */
#define DEFAULT_MEMORY_SIZE       1024
#define DEFAULT_PRIORITY          10
#define LINK_PRIORITY             11
#define NX_APP_CABLE_CONNECTION_CHECK_PERIOD  100
/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
TX_THREAD      NxAppThread;
NX_PACKET_POOL NxAppPool;
NX_IP          NetXDuoEthIpInstance;
/* USER CODE BEGIN PV */
/* TCP Echo Server variables */
NX_TCP_SOCKET TCPSocket;
#define TCP_ECHO_PORT 7
#define TCP_WINDOW_SIZE 512

/* External UART functions from main.c */
extern volatile uint8_t uart_data_ready;
extern uint16_t UART_GetData(uint8_t *buffer, uint16_t max_len);
extern uint8_t UART_DataAvailable(void);

/* Thread for TCP Echo */
TX_THREAD TcpEchoThread;

/* Buffer for data */
static uint8_t echo_buffer[512];
/* Define Threadx global data structures. */
TX_THREAD AppServerThread;
TX_THREAD LedThread;
TX_THREAD AppLinkThread;

/* Led toggling thread entry */
void LedThread_Entry(ULONG thread_input);

/* Define NetX global data structures. */

NX_PACKET_POOL WebServerPool;

ULONG IpAddress;
ULONG NetMask;
ULONG free_bytes;

NX_WEB_HTTP_SERVER HTTPServer;

/* Set nx_server_pool start address */
#if defined ( __ICCARM__ ) /* IAR Compiler */
#pragma location = ".NxServerPoolSection"
#elif defined ( __CC_ARM ) || defined(__ARMCC_VERSION) /* ARM Compiler 5/6 */
__attribute__((section(".NxServerPoolSection")))
#elif defined ( __GNUC__ ) /* GNU Compiler */
__attribute__((section(".NxServerPoolSection")))
#endif

/* Define FileX global data structures. */

/* the server reads the content from the uSD, a FX_MEDIA instance is required */
FX_MEDIA                Flash_Media;

/* Buffer for FileX FX_MEDIA sector cache. this should be 32-Bytes aligned to avoid
   cache maintenance issues */
ALIGN_32BYTES (uint32_t DataBuffer[512]);
/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
static VOID nx_app_thread_entry (ULONG thread_input);
/* USER CODE BEGIN PFP */
static void Tcp_Echo_Thread_Entry(ULONG thread_input);
static VOID App_Link_Thread_Entry(ULONG thread_input);
static VOID App_Link_Thread_Entry(ULONG thread_input);
/* USER CODE END PFP */

/**
  * @brief  Application NetXDuo Initialization.
  * @param memory_ptr: memory pointer
  * @retval int
  */
UINT MX_NetXDuo_Init(VOID *memory_ptr)
{
  UINT ret = NX_SUCCESS;
  TX_BYTE_POOL *byte_pool = (TX_BYTE_POOL*)memory_ptr;
  CHAR *pointer;

  /* USER CODE BEGIN MX_NetXDuo_MEM_POOL */
  /* USER CODE END MX_NetXDuo_MEM_POOL */

  /* USER CODE BEGIN 0 */

  /* USER CODE END 0 */

  /* Initialize the NetXDuo system. */
  nx_system_initialize();

    /* Allocate the memory for packet_pool.  */
  if (tx_byte_allocate(byte_pool, (VOID **) &pointer, NX_APP_PACKET_POOL_SIZE, TX_NO_WAIT) != TX_SUCCESS)
  {
    return TX_POOL_ERROR;
  }

  /* Create the Packet pool to be used for packet allocation,
   * If extra NX_PACKET are to be used the NX_APP_PACKET_POOL_SIZE should be increased
   */
  ret = nx_packet_pool_create(&NxAppPool, "NetXDuo App Pool", DEFAULT_PAYLOAD_SIZE, pointer, NX_APP_PACKET_POOL_SIZE);

  if (ret != NX_SUCCESS)
  {
    return NX_POOL_ERROR;
  }

    /* Allocate the memory for Ip_Instance */
  if (tx_byte_allocate(byte_pool, (VOID **) &pointer, Nx_IP_INSTANCE_THREAD_SIZE, TX_NO_WAIT) != TX_SUCCESS)
  {
    return TX_POOL_ERROR;
  }

   /* Create the main NX_IP instance */
  ret = nx_ip_create(&NetXDuoEthIpInstance, "NetX Ip instance", NX_APP_DEFAULT_IP_ADDRESS, NX_APP_DEFAULT_NET_MASK, &NxAppPool, nx_stm32_eth_driver,
                     pointer, Nx_IP_INSTANCE_THREAD_SIZE, NX_APP_INSTANCE_PRIORITY);

  if (ret != NX_SUCCESS)
  {
    return NX_NOT_SUCCESSFUL;
  }

    /* Allocate the memory for ARP */
  if (tx_byte_allocate(byte_pool, (VOID **) &pointer, DEFAULT_ARP_CACHE_SIZE, TX_NO_WAIT) != TX_SUCCESS)
  {
    return TX_POOL_ERROR;
  }

  /* Enable the ARP protocol and provide the ARP cache size for the IP instance */

  /* USER CODE BEGIN ARP_Protocol_Initialization */

  /* USER CODE END ARP_Protocol_Initialization */

  ret = nx_arp_enable(&NetXDuoEthIpInstance, (VOID *)pointer, DEFAULT_ARP_CACHE_SIZE);

  if (ret != NX_SUCCESS)
  {
    return NX_NOT_SUCCESSFUL;
  }

  /* Enable the ICMP */

  /* USER CODE BEGIN ICMP_Protocol_Initialization */

  /* USER CODE END ICMP_Protocol_Initialization */

  ret = nx_icmp_enable(&NetXDuoEthIpInstance);

  if (ret != NX_SUCCESS)
  {
    return NX_NOT_SUCCESSFUL;
  }

  /* Enable TCP Protocol */

  /* USER CODE BEGIN TCP_Protocol_Initialization */

  /* USER CODE END TCP_Protocol_Initialization */

  ret = nx_tcp_enable(&NetXDuoEthIpInstance);

  if (ret != NX_SUCCESS)
  {
    return NX_NOT_SUCCESSFUL;
  }

  /* Enable the UDP protocol required for  DHCP communication */

  /* USER CODE BEGIN UDP_Protocol_Initialization */

  /* USER CODE END UDP_Protocol_Initialization */

  ret = nx_udp_enable(&NetXDuoEthIpInstance);

  if (ret != NX_SUCCESS)
  {
    return NX_NOT_SUCCESSFUL;
  }

   /* Allocate the memory for main thread   */
  if (tx_byte_allocate(byte_pool, (VOID **) &pointer, NX_APP_THREAD_STACK_SIZE, TX_NO_WAIT) != TX_SUCCESS)
  {
    return TX_POOL_ERROR;
  }

  /* Create the main thread */
  ret = tx_thread_create(&NxAppThread, "NetXDuo App thread", nx_app_thread_entry , 0, pointer, NX_APP_THREAD_STACK_SIZE,
                         NX_APP_THREAD_PRIORITY, NX_APP_THREAD_PRIORITY, TX_NO_TIME_SLICE, TX_AUTO_START);

  if (ret != TX_SUCCESS)
  {
    return TX_THREAD_ERROR;
  }

  /* USER CODE BEGIN MX_NetXDuo_Init */
  printf("UART-to-Ethernet Echo application started..\n");

  /* Allocate the TCP Echo thread stack */
  ret = tx_byte_allocate(byte_pool, (VOID **) &pointer, 2 * DEFAULT_MEMORY_SIZE, TX_NO_WAIT);
  if (ret != TX_SUCCESS)
  {
      printf("TCP Echo thread memory allocation failed: 0x%02x\n", ret);
      Error_Handler();
  }

  /* Create the TCP Echo thread */
  ret = tx_thread_create(&TcpEchoThread, "TCP Echo Thread", Tcp_Echo_Thread_Entry, 0, pointer, 2 * DEFAULT_MEMORY_SIZE,
                         DEFAULT_PRIORITY, DEFAULT_PRIORITY, TX_NO_TIME_SLICE, TX_DONT_START);
  if (ret != TX_SUCCESS)
  {
      printf("TCP Echo thread creation failed: 0x%02x\n", ret);
      Error_Handler();
  }

  /* Allocate the memory for Link thread */
  if (tx_byte_allocate(byte_pool, (VOID **) &pointer, 2 * DEFAULT_MEMORY_SIZE, TX_NO_WAIT) != TX_SUCCESS)
  {
      return TX_POOL_ERROR;
  }

  /* Create the Link thread */
  ret = tx_thread_create(&AppLinkThread, "App Link Thread", App_Link_Thread_Entry, 0, pointer, 2 * DEFAULT_MEMORY_SIZE,
                         LINK_PRIORITY, LINK_PRIORITY, TX_NO_TIME_SLICE, TX_AUTO_START);
  if (ret != TX_SUCCESS)
  {
      return NX_NOT_ENABLED;
  }
  /* USER CODE END MX_NetXDuo_Init */

  return ret;
}

/**
* @brief  Main thread entry.
* @param thread_input: ULONG user argument used by the thread entry
* @retval none
*/
static VOID nx_app_thread_entry (ULONG thread_input)
{
  /* USER CODE BEGIN Nx_App_Thread_Entry 0 */

  /* USER CODE END Nx_App_Thread_Entry 0 */

}
/* USER CODE BEGIN 2 */
/**
* @brief  TCP Echo Thread - forwards UART data to TCP client
* @param  thread_input: ULONG thread parameter
* @retval none
*/
static void Tcp_Echo_Thread_Entry(ULONG thread_input)
{
    UINT status;
    NX_PACKET *packet_ptr;
    ULONG bytes_read;

    NX_PARAMETER_NOT_USED(thread_input);

    printf("TCP Echo Thread started\n");

    /* Create TCP socket */
    status = nx_tcp_socket_create(&NetXDuoEthIpInstance, &TCPSocket, "TCP Echo Socket",
                                  NX_IP_NORMAL, NX_FRAGMENT_OKAY, NX_IP_TIME_TO_LIVE, TCP_WINDOW_SIZE,
                                  NX_NULL, NX_NULL);
    if (status != NX_SUCCESS)
    {
        printf("TCP socket creation failed: 0x%02x\n", status);
        return;
    }

    /* Bind socket to port */
    status = nx_tcp_server_socket_listen(&NetXDuoEthIpInstance, TCP_ECHO_PORT, &TCPSocket, 5, NX_NULL);
    if (status != NX_SUCCESS)
    {
        printf("TCP listen failed: 0x%02x\n", status);
        return;
    }

    printf("TCP Echo Server listening on port %d\n", TCP_ECHO_PORT);
    printf("Connect with: telnet 192.168.1.2 %d\n", TCP_ECHO_PORT);

    while (1)
    {
        /* Wait for a client connection */
        printf("Waiting for TCP client connection...\n");
        status = nx_tcp_server_socket_accept(&TCPSocket, NX_WAIT_FOREVER);

        if (status == NX_SUCCESS)
        {
            printf("TCP Client connected!\n");

            /* Connection established - now echo data */
            while (1)
            {
                /* Check for data from TCP client */
                status = nx_tcp_socket_receive(&TCPSocket, &packet_ptr, 100);  /* 100 tick timeout */
                if (status == NX_SUCCESS)
                {

                    nx_packet_data_retrieve(packet_ptr, echo_buffer, &bytes_read);
                    echo_buffer[bytes_read] = '\0';

                    printf("TCP->UART: %s", echo_buffer);

                    /* Also send it back to TCP client (echo) */
                    nx_tcp_socket_send(&TCPSocket, packet_ptr, NX_WAIT_FOREVER);
                }
                else if (status == NX_NO_PACKET)
                {
                    /* No TCP data, check for UART data */
                    if (UART_DataAvailable())
                    {
                        uint16_t len = UART_GetData(echo_buffer, sizeof(echo_buffer) - 1);
                        if (len > 0)
                        {
                            echo_buffer[len] = '\0';
                            printf("UART->TCP: %s\n", echo_buffer);

                            /* Allocate packet and send to TCP client */
                            status = nx_packet_allocate(&NxAppPool, &packet_ptr, NX_TCP_PACKET, NX_WAIT_FOREVER);
                            if (status == NX_SUCCESS)
                            {
                                nx_packet_data_append(packet_ptr, echo_buffer, len, &NxAppPool, NX_WAIT_FOREVER);
                                status = nx_tcp_socket_send(&TCPSocket, packet_ptr, 100);
                                if (status != NX_SUCCESS)
                                {
                                    nx_packet_release(packet_ptr);
                                    printf("TCP send failed: 0x%02x\n", status);
                                }
                            }
                        }
                    }
                }
                else
                {
                    /* Connection error - client disconnected */
                    printf("TCP Client disconnected (status: 0x%02x)\n", status);
                    break;
                }

                tx_thread_sleep(1);  /* Small delay */
            }

            /* Disconnect and unaccept */
            nx_tcp_socket_disconnect(&TCPSocket, 100);
            nx_tcp_server_socket_unaccept(&TCPSocket);
            nx_tcp_server_socket_relisten(&NetXDuoEthIpInstance, TCP_ECHO_PORT, &TCPSocket);
        }
    }
}

/**
* @brief  Link thread entry - monitors Ethernet connection
* @param  thread_input: ULONG thread parameter
* @retval none
*/
static VOID App_Link_Thread_Entry(ULONG thread_input)
{
    ULONG actual_status;
    UINT linkdown = 1;  /* Start assuming link is down */
    UINT status;
    UINT server_started = 0;

    while(1)
    {
        /* Get Physical Link status */
        status = nx_ip_interface_status_check(&NetXDuoEthIpInstance, 0, NX_IP_LINK_ENABLED,
                                              &actual_status, 10);

        if(status == NX_SUCCESS)
        {
            if(linkdown == 1)
            {
                linkdown = 0;
                printf("The network cable is connected.\n");

                /* Send command to Enable Nx driver */
                nx_ip_driver_direct_command(&NetXDuoEthIpInstance, NX_LINK_ENABLE, &actual_status);

                /* Set static IP address */
                IpAddress = IP_ADDRESS(192, 168, 1, 2);
                NetMask = IP_ADDRESS(255, 255, 255, 0);

                status = nx_ip_address_set(&NetXDuoEthIpInstance, IpAddress, NetMask);
                if (status == NX_SUCCESS)
                {
                    printf("Static IP configured: 192.168.1.2\n");
                }
                else
                {
                    printf("Failed to set IP: 0x%02x\n", status);
                }

                /* Start the TCP Echo thread only once */
                if (server_started == 0)
                {
                    tx_thread_resume(&TcpEchoThread);
                    server_started = 1;
                    printf("TCP Echo server started!\n");
                }
            }
        }
        else
        {
            if(linkdown == 0)
            {
                linkdown = 1;
                printf("The network cable is not connected.\n");
            }
        }

        tx_thread_sleep(NX_APP_CABLE_CONNECTION_CHECK_PERIOD);
    }
}
/* USER CODE END 2 */
